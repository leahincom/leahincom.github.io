<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Sans KR:300,300italic,400,400italic,700,700italic|Source Code Pro for Powerline:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leahincom.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="3.1 MNISTsklearn.datasets : Toy datasets를 담은 lib (크기가 작아 학습용이 아닌 샘플용으로 사용) 일반적인 구조 ⇒ 쓸 수 있는 keys :  데이터셋을 설명하는 DESCR 키 샘플이 하나의 행, 특성이 하나의 열로 구성된 배열을 가진 data 키 레이블 배열을 담은 target 키 등등      1234from skle">
<meta property="og:type" content="article">
<meta property="og:title" content="3장: 분류">
<meta property="og:url" content="https://leahincom.github.io/2021/05/24/HandsonML-ch3/index.html">
<meta property="og:site_name" content="leah">
<meta property="og:description" content="3.1 MNISTsklearn.datasets : Toy datasets를 담은 lib (크기가 작아 학습용이 아닌 샘플용으로 사용) 일반적인 구조 ⇒ 쓸 수 있는 keys :  데이터셋을 설명하는 DESCR 키 샘플이 하나의 행, 특성이 하나의 열로 구성된 배열을 가진 data 키 레이블 배열을 담은 target 키 등등      1234from skle">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-24T14:24:28.000Z">
<meta property="article:modified_time" content="2021-05-24T06:36:43.234Z">
<meta property="article:author" content="JungHyun">
<meta property="article:tag" content="machine learning">
<meta property="article:tag" content="Hands-On Machine Learning">
<meta property="article:tag" content="Keras">
<meta property="article:tag" content="Tensorflow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://leahincom.github.io/2021/05/24/HandsonML-ch3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>3장: 분류 | leah</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">leah</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">my dev_log</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leahincom.github.io/2021/05/24/HandsonML-ch3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.jpeg">
      <meta itemprop="name" content="JungHyun">
      <meta itemprop="description" content="Continuously Growing Developer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leah">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          3장: 분류
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-24 15:24:28 / Modified: 07:36:43" itemprop="dateCreated datePublished" datetime="2021-05-24T15:24:28+01:00">2021-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index"><span itemprop="name">ML</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ML/Hands-On/" itemprop="url" rel="index"><span itemprop="name">Hands-On</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="3-1-MNIST"><a href="#3-1-MNIST" class="headerlink" title="3.1 MNIST"></a>3.1 MNIST</h2><p>sklearn.datasets : Toy datasets를 담은 lib (크기가 작아 학습용이 아닌 샘플용으로 사용)</p>
<p>일반적인 구조 ⇒ 쓸 수 있는 keys :</p>
<ul>
<li>데이터셋을 설명하는 DESCR 키</li>
<li>샘플이 하나의 행, 특성이 하나의 열로 구성된 배열을 가진 data 키</li>
<li>레이블 배열을 담은 target 키</li>
<li>등등</li>
</ul>
<br />



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets </span><br><span class="line"><span class="keyword">import</span> fetch_openml </span><br><span class="line">mnist = fetch_openml(<span class="string">&#x27;mnist_784&#x27;</span>, version=<span class="number">1</span>) </span><br><span class="line">mnist.keys()  &gt;&gt;&gt; dict_keys([<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;feature_names&#x27;</span>, <span class="string">&#x27;DESCR&#x27;</span>, <span class="string">&#x27;details&#x27;</span>, <span class="string">&#x27;categories&#x27;</span>, <span class="string">&#x27;url&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>위의 결과는 mnist의 key들로, dictionary 구조를 가진 mnist에 대해 쓸 수 있는 명령들을 의미한다.</p>
<br />



<hr>
<ol>
<li>data : 학습용(feed) 데이터</li>
<li>target : label 데이터로, 분류될 class를 의미</li>
</ol>
<p>따라서,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X, y = mnist[<span class="string">&quot;data&quot;</span>], mnist[<span class="string">&quot;target&quot;</span>] </span><br><span class="line">X.shape &gt;&gt;&gt; (<span class="number">70000</span>, <span class="number">784</span>) <span class="comment"># 784 = 28*28 y.shape &gt;&gt;&gt; (70000,)</span></span><br></pre></td></tr></table></figure>
<p>X.shape는 70000개의 data에 대해 각 data 당 28*28에 해당하는 pixel 강도(0~255)을 담고 있는 배열을 나타내고,</p>
<p>y.shape는 70000개의 분류된 class를 나타낸다.</p>
<hr>
<p>mnist의 data를 담은 X 배열에서 하나의 이미지를 예시로 추출하여 출력해보도록 한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_digit = X[<span class="number">0</span>] <span class="comment"># 0번째 data some_digit_image = some_digit.reshape(28, 28) # 28*28 size에 맞게 벡터 reshape</span></span><br></pre></td></tr></table></figure>
<p>some_digit.reshape(28, 28)이 의미하는 바는, 현재 [1, 784]로 저장되어 있는 X[0]의 이미지 벡터는 [28,28]의 배열로 reshaping한다는 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[<span class="number">0</span>] &gt;&gt;&gt; <span class="string">&#x27;5&#x27;</span></span><br></pre></td></tr></table></figure>
<p>y에는 분류된 class가 담기므로, X[0]은 ‘5’ class에 속하는 data라는 것이다.</p>
<p>위에서 출력된 것은 ‘(작은따옴표)’로부터 알 수 있듯이 string data이므로 이를 정수로 바꾸는 코드가 다음과 같다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = y.astype(np.uint8)</span><br></pre></td></tr></table></figure>
<hr>
<br />



<p>1장에서 공부했듯이, 위의 MNIST은 지도 학습 모델이므로,</p>
<p>더 좋은 training result를 내기 위해서는 하나의 dataset에서 train dataset과 test dataset을 적절히 나누어야 한다. 따라서 해당 MNIST에서는 6:1로(전체 7만개의 dataset) train 및 test dataset을 나누었다.</p>
<p>또한 MNIST dataset은 데이터셋이 적절히 섞여 있어, 교차 검증 폴드(train / test set 간 분포의 균질성)가 비슷하고 훈련 샘플의 순서에 따른 성능 저하를 방지한다.</p>
<br />



<h2 id="3-2-이진-분류기-훈련"><a href="#3-2-이진-분류기-훈련" class="headerlink" title="3.2 이진 분류기 훈련"></a>3.2 이진 분류기 훈련</h2><p>이진 분류기 : YES or NO로 class 분류</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_train_5 = (y_train == <span class="number">5</span>)</span><br><span class="line">y_test_5 = (y_test == <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>위의 2가지 변수는 “감지기” 그 자체이다. 즉, 오른쪽 조건이 True인지 False인지 판단하는 감지기의 역할을 한다.</p>
<p>분류 모델로 사용할 SGD(Stochastic Gradient Descent) 분류기는 손실함수 자체를 최소화하는 것이 아닌, 손실함수의 기댓값을 최소화하는 방법을 이용한다. 즉, gradient가 아닌 gradient의 기댓값의 추정치를 이용한다. 이에 사용되는 수식은 다음과 같다. 𝑤(𝑘+1)=𝑤(𝑘)+E[∇𝐿]. 모든 학습 데이터를 사용하는 것이 아닌 minibatch(일부 데이터, 하나의 훈련 샘플 그룹)를 이용하여 gradient의 추정치를 구하므로, gradient의 기댓값의 추정치는 표본 평균으로 작용한다. 따라서 계산량과 학습 데이터가 많은 deep learning과 온라인 학습(미니배치 이용)에 적합하다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model </span><br><span class="line"><span class="keyword">import</span> SGDClassifier </span><br><span class="line">sgd_clf = SGDClassifier(random_state=<span class="number">42</span>) </span><br><span class="line">sgd_clf.fit(X_train, y_train_5) sgd_clf.predict([some_digit]) &gt;&gt;&gt; array([ <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>
<p>SGDClassifier(random_state=42)에서 random_state은 무작위 값을 넣으며 최적값을 찾는 SGDClassifier의 특성에 따라, 이전에 실행했던 결과값을 repeatable하게 받기 위해 특정값을 저장하는 것을 의미한다. 값의 의미는 딱히 없으므로, 아무 정수로 설정할 수 있다. 이 후 classifier에 data와 y_train_5를 넣어 classifier을 fitting한다.</p>
<p>classifier은 predict의 결과로 some_digit(=X[0])을 넣었을 때 y_train_5에 따라 5 여부를 감지한 결과를 array에 담는다.</p>
<br />



<h2 id="3-3-성능-측정"><a href="#3-3-성능-측정" class="headerlink" title="3.3 성능 측정"></a>3.3 성능 측정</h2><h3 id="3-3-1-교차-검증을-사용한-정확도-측정"><a href="#3-3-1-교차-검증을-사용한-정확도-측정" class="headerlink" title="3.3.1 교차 검증을 사용한 정확도 측정"></a>3.3.1 교차 검증을 사용한 정확도 측정</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection </span><br><span class="line"><span class="keyword">import</span> StratifiedKFold </span><br><span class="line"><span class="keyword">from</span> sklearn.base </span><br><span class="line"><span class="keyword">import</span> clone skfolds = StratifiedKFold(n_splits=<span class="number">3</span>, random_state=<span class="number">42</span>) </span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> skfolds.split(X_train, y_train_5) : </span><br><span class="line">	clone_clf = clone(sgd_clf) </span><br><span class="line">	X_train_folds = X_train[train_index] </span><br><span class="line">	y_train_folds = y_train_5[train_index] </span><br><span class="line">	X_test_fold = X_train[test_index] </span><br><span class="line">	y_test_fold = y_train[test_index] </span><br><span class="line">clone_clf.fit(X_train_folds, y_train_folds) </span><br><span class="line">y_pred = clone_clf.predict(X_test_fold) </span><br><span class="line">n_correct = <span class="built_in">sum</span>(y_pred == y_test_fold) </span><br><span class="line">print(n_correct / <span class="built_in">len</span>(y_pred)) &gt;&gt;&gt; <span class="number">0.9502</span>, <span class="number">0.96565</span>, <span class="number">0.96495</span></span><br></pre></td></tr></table></figure>
<p>StartifiedKFold에서 n_splits=3으로 설정하였으므로, 폴드가 3개인 k-겹 교차 검증이 수행된다.</p>
<p>train/test_index으로 skfolds 객체의 split()을 호출하여 학습용/검증용 데이터로 분할할 수 있는 인덱스를 반환받고 실제 분할된 데이터를 해당 index를 대입하여 추출한다. 이 때, split()의 대상은 X_train → y_train_5 집합이다. 이를 토대로 y 값의 prediction인 y_pred를 X_test_fold로부터 predict하고, 올바른 예측의 수를 y_pred와 y_test_fold를 비교하여 sum 값을 통해 계산한다.</p>
<p>위의 과정은 sklearn의 cross_val_score과 거의 같은 기능을 나타내므로 다음과 같은 코드로 정리할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score </span><br><span class="line">cross_val_score(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>, scoring=<span class="string">&quot;accuracy&quot;</span>) &gt;&gt;&gt; array([<span class="number">0.96355</span>, <span class="number">0.93795</span>, <span class="number">0.95615</span>])</span><br></pre></td></tr></table></figure>
<p>이는 약 95%로 굉장히 높은 정확도를 나타낸다. 하지만, 이러한 정확도를 성능 측정 지표로 사용하지 않는 이유는 다음과 같다.</p>
<br />



<hr>
<p>위의 예시와 반대로, 5가 아닌 클래스를 분류하는 더미 분류기를 만들어 정확도를 비교해볼 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.base </span><br><span class="line"><span class="keyword">import</span> BaseEstimator </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Never5Classifier</span>(<span class="params">BaseEstimator</span>) :</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>) :</span> </span><br><span class="line">		<span class="keyword">return</span> self </span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>) :</span> </span><br><span class="line">		<span class="keyword">return</span> np.zeros((<span class="built_in">len</span>(X), <span class="number">1</span>), dtype=<span class="built_in">bool</span>) </span><br><span class="line"></span><br><span class="line">never_5_clf = Never5Classifier() </span><br><span class="line">cross_val_score(never_5_clf, X_train, y_train_5, cv=<span class="number">3</span>, scoring=<span class="string">&quot;accuracy&quot;</span>) &gt;&gt;&gt; array([<span class="number">0.91125</span>, <span class="number">0.90855</span>, <span class="number">0.90915</span>])</span><br></pre></td></tr></table></figure>
<p>이 때 Never5Classifier의 predict 함수는 배열의 결과를 전부 False로 세팅하여 배열을 반환한다.</p>
<p>해당 classifier을 cross_val_score에 적용할 시 정확도가 90% 가량 나오는 것을 확인할 수 있다. 이는 약 10%의 이미지가 숫자 5이므로 이를 제외한 90%를 정확도로 출력한다. 따라서, 불균형한 데이터셋(5임/5가 아님 = 어떤 클래스가 다른 것보다 월등히 많음)을 다룰 때는 정확도를 분류기의 성능 측정 지표로 선호하지 않는다.</p>
<br />



<h3 id="3-3-2-오차-행렬"><a href="#3-3-2-오차-행렬" class="headerlink" title="3.3.2 오차 행렬"></a>3.3.2 오차 행렬</h3><p>오차 행렬 : 데이터와 다른 클래스로 잘못 분류한 횟수를 담은 행렬</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection </span><br><span class="line"><span class="keyword">import</span> cross_val_predict </span><br><span class="line">y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>cross_val_score()</code> : 테스트 세트의 output의 평균을 이용해 평가 점수 반환</p>
<p><code>cross_val_predict()</code> : 테스트 세트의 input의 각 element에 대한 깨끗한 예측 반환 (훈련하는 동안 사용되지 않은 데이터에 대해 예측)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confusion_matrix(y_train_5, y_train_pred) &gt;&gt;&gt; array([[<span class="number">53057</span>, <span class="number">1522</span>], [<span class="number">1325</span>, <span class="number">4096</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>행 : 실제 클래스 (데이터)</li>
<li>열 : 예측한 클래스</li>
</ul>
<p>따라서, 위의 결과에서 첫 번째 행이 “5 아님”(음성 클래스)일 때, 첫 번째 열은 True Negative(예측 N, 실제 N)을 나타내며, 두 번째 열은 False Positive(예측 P, 실제 N)를 나타낸다. 두 번째 행은 “5임”(양성 클래스)이며, 첫 번째 열은 FN(예측 N, 실제 P), 두 번째 열은 TP(예측 P, 실제 P)이다.</p>
<hr>
<p>이에 완벽한 분류기는 TP와 TN만 가지고 있을 것이므로, 실제 confusion matrix의 출력값은 주대각선 값만 존재한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_train_perfect_predictions = y_train_5 confusion_matrix(y_train_5, y_train_perfect_predictions) &gt;&gt;&gt; array([[<span class="number">54579</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">5421</span>]])</span><br></pre></td></tr></table></figure>
<br />



<h3 id="3-3-3-정밀도와-재현율"><a href="#3-3-3-정밀도와-재현율" class="headerlink" title="3.3.3 정밀도와 재현율"></a>3.3.3 정밀도와 재현율</h3><ul>
<li>정밀도 = 정확도 = TP / (TP+FP)</li>
<li>재현율 = 민감도 = TP / (TP+FN)</li>
</ul>
<p>정밀도는 예측이 양성인 결과(TP, FP)를, 재현율은 실제 양성인 결과(TP,FN)를 이용한다.</p>
<p>즉, 정밀도는 확실한 양성 샘플 하나만 예측할 시 1이 나오지만 이는 다른 모든 양성 샘플을 무시한 결과이므로, 재현율(민감도 또는 진짜 양성 비율)과 같은 다른 지표와 함께 사용해야 한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">precision_score(y_train_5, y_train_pred) // 정밀도 &gt;&gt;&gt; <span class="number">0.729085</span>... </span><br><span class="line">recall_score(y_train_5, y_train_pred) // 재현율 &gt;&gt;&gt; <span class="number">0.755580</span>...</span><br></pre></td></tr></table></figure>
<p>0.729는 정밀도로, 5로 판별된 이미지 중 72.9%가 정확하다는 의미이며, 0.756은 재현율으로, 전체 숫자 5에서 75.6%의 5만 감지한 것을 의미한다.</p>
<br />

<hr>
<p>이를 하나의 숫자로 통합해 살펴볼 수 있는 평가 지표가 F1 점수, 즉 정밀도와 재현율의 조화 평균이다.</p>
<ul>
<li>F1 = TP / (TP + (FN + FP) / 2)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1_score(y_train_5, y_train_pred) &gt;&gt;&gt; <span class="number">0.742096</span>...</span><br></pre></td></tr></table></figure>
<p>정밀도와 재현율이 비슷할 시 F1의 값이 높게 나오므로 간단한 평가 지표로 이용할 수 있지만,</p>
<p>정밀도/재현율 트레이드오프에 따라 정밀도와 재현율이 반비례하는 경우 상황에 따라 둘의 중요성이 달라지므로 F1을 주요 평가 지표로 사용하는 것이 바람직하지 않다.</p>
<br />



<h3 id="3-3-4-정밀도-재현율-트레이드오프"><a href="#3-3-4-정밀도-재현율-트레이드오프" class="headerlink" title="3.3.4 정밀도/재현율 트레이드오프"></a>3.3.4 정밀도/재현율 트레이드오프</h3><p>정밀도와 재현율은 결정 함수의 결과로 나온 output dataset에 적용하는 임곗값에 따라 달라진다.</p>
<p>즉, 임곗값을 높게 설정할 경우 정밀도는 높아지나 포함되는 TP가 낮아지므로 재현율은 떨어지며, 임곗값을 낮게 설정할 경우 정밀도는 떨어지나 재현율은 높아진다. some_digit의 예측에 사용한 점수를 확인하고 임곗값을 정해 양성/음성 예측을 만들기 위해 decision_function()을 이용한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_scores = sgd_clf.decision_function([some_digit]) </span><br><span class="line">y_scores &gt;&gt;&gt; array([<span class="number">2412.53175101</span>]) </span><br><span class="line">threshold = <span class="number">0</span> </span><br><span class="line">y_some_digit_pred = (y_scores &gt; threshold) &gt;&gt;&gt; array([ <span class="literal">True</span>]) </span><br><span class="line">threshold = <span class="number">8000</span> </span><br><span class="line">y_some_digit_pred = (y_scores &gt; threshold) y_some_digit_[red &gt;&gt;&gt; array([<span class="literal">False</span>])</span><br></pre></td></tr></table></figure>
<p>따라서 적절한 임곗값을 설정하기 위하여, cross_val_predict()의 decision_function을 이용하여 모든 샘플의 결정 점수를 얻는다. 이후 precision_recall_curve()를 이용해 가능한 임곗값에 대한 정밀도와 재현율을 얻는다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>, method=<span class="string">&quot;decision_function&quot;</span>) </span><br><span class="line">precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>
<p>좋은 정밀도/재현율 트레이드오프는 재현율에 대한 정밀도 곡선에서 정밀도가 급격하게 줄어드는 지점 직전의 값으로 임곗값을 설정하면 된다.</p>
<p>또한 특정한 목표치의 정밀도를 달성하는 것이 목표(n%라고 가정해보자.)일 때는, 다음과 같이 임곗값을 설정하면 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threshold_90_precision = thresholds[np.argmax(precisions &gt;= n / <span class="number">100</span>)] </span><br><span class="line">y_train_pred_90 = (y_scores &gt;= threshold_90_precision) </span><br><span class="line">precision_score(y_train_5, y_train_pred_90) &gt;&gt;&gt; <span class="number">0.900038</span>... </span><br><span class="line">recall_score(y_train_5, y_train_pred_90) &gt;&gt;&gt; <span class="number">0.436819</span>...</span><br></pre></td></tr></table></figure>
<p>하지만 재현율이 너무 낮을 경우, 높은 정밀도의 분류기는 유용하지 않다.</p>
<br />



<h3 id="3-3-5-ROC-곡선"><a href="#3-3-5-ROC-곡선" class="headerlink" title="3.3.5 ROC 곡선"></a>3.3.5 ROC 곡선</h3><p>ROC 곡선 : 거짓 양성 비율(FPR)에 대한 진짜 양성 비율(TPR, 재현율)의 곡선으로, FPR = 1(실제 음성) - TNR이다. 이 때 TNR을 특이도라고 하며, ROC를 재현율에 대한 1-특이도라고 한다.</p>
<p>TPR과 FPR을 계산하기 위해 사용되는 함수는 roc_curve()로, 다음과 같이 사용된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>
<p>TPR이 높아질 수록 FPR도 높아지므로, 좋은 분류기는 완전한 랜덤 분류기(TPR : FPR = 1 : 1)에서 최대한 왼쪽 위 모서리(TPR은 높고 FPR은 낮은)로 멀리 떨어져야 한다. 이를 평가하는 지표로는 곡선 아래의 면적(AUC)가 있는데, AUC를 계산하기 위해 RandomForestClassifier을 이용한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier </span><br><span class="line">forest_clf = RandomForestClassifier(random_state = <span class="number">42</span>) </span><br><span class="line">y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=<span class="number">3</span>, method=<span class="string">&quot;predict_proba&quot;</span>) </span><br><span class="line">y_scores_forest = y_probas_forest[:, <span class="number">1</span>] </span><br><span class="line">roc_auc_score(y_train_5, y_scores_forest)</span><br></pre></td></tr></table></figure>
<p>RandomForestClassifier에서는 decision_function 대신 predict_proba 기능을 제공한다.</p>
<p>그 결과로서, RandomForestClassifier는 SGDClassifier보다 왼쪽 위 모서리에 더 가까운 ROC 곡선을 생성하므로 AUC 점수로 더 높다.</p>
<br />



<h2 id="3-4-다중-분류"><a href="#3-4-다중-분류" class="headerlink" title="3.4 다중 분류"></a>3.4 다중 분류</h2><p>다중 분류기로 둘 이상의 클래스를 구별할 수 있으나, 보통 이진 분류기를 이용해 다음과 같은 2가지의 방법으로 다중 클래스를 구별한다. 보통 다중 클래스 분류 작업에 이진 분류 알고리즘을 선택하면 자동적으로 OvR이나 OvO를 실행하지만, import를 통해 클래스 객체를 생성하여 강제적으로 원하는 Classifier을 설정할 수도 있다.</p>
<ul>
<li>OvR(OvA) : 특정 클래스만 구분하는 클래스별 이진 분류기 n개를 훈련시켜 클래스가 n개의 클래스 분류 시스템을 만든다. 이후 각 분류기의 결정 점수 중에서 가장 높은 것을 클래스로 선택한다. 이는 큰 훈련 세트에서 적은 분류기를 훈련시킨다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.multiclass <span class="keyword">import</span> OneVsRestClassifier</span><br></pre></td></tr></table></figure>
<ul>
<li>OvO : 각 클래스의 조합마다 이진 분류기를 훈련시킨다. 이 중 가장 많이 양성으로 분류된 클래스를 선택한다. 이는 각 분류기의 훈련에 전체 훈련 세트 중 구별할 두 클래스의 샘플만 필요하므로, 작은 훈련 세트에서 많은 분류기를 훈련시킬 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.multiclass <span class="keyword">import</span> OneVsOneClassifier</span><br></pre></td></tr></table></figure>
<p>더 높은 정확도를 위해, 입력의 스케일을 조정하면 분류기의 성능을 높일 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandartScaler </span><br><span class="line">scaler = StandardScaler() </span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train.astype(float64))</span><br></pre></td></tr></table></figure>
<br />



<h2 id="3-5-에러-분석"><a href="#3-5-에러-분석" class="headerlink" title="3.5 에러 분석"></a>3.5 에러 분석</h2><p>cross_val_predict()를 이용해 결과값을 예측하고, 이 후 confusion_matrix()를 이용해 오차 행렬을 생성한다. 그 후 matshow()를 실행 시, 각 클래스 별로 예측한 클래스의 확률이 밝기로 나타나는데, 밝을 수록 높은 확률을 나타낸다. 따라서 올바른 오차 행렬은 주대각선의 밝기가 밝고, 나머지는 어두워야 한다.</p>
<p>이러한 오차 행렬의 특성에 따라 잘못 분류된 클래스를 파악하고 분류기의 성능 향상 방안에 대해 생각해볼 수 있다. 특히 이 과정에서 데이터의 전처리가 중요한데, 3과 5의 클래스를 분류하는 예시의 경우 SGDClassifier을 적용할 경우 미세한 픽셀 강도의 차이가 클래스 분류의 오류로 이어지므로 이미지의 회전값을 0으로 조정하는 것이 이에 해당한다.</p>
<br />



<h2 id="3-6-다중-레이블-분류"><a href="#3-6-다중-레이블-분류" class="headerlink" title="3.6 다중 레이블 분류"></a>3.6 다중 레이블 분류</h2><p>다중 레이블 분류 시스템 : 하나의 샘플에 여러 개의 클래스가 포함될 경우, 레이블을 달아 각 클래스를 구별하는 시스템</p>
<p>다중 레이블 분류 시 적절한 지표를 사용하는 것이 중요한데, 다음과 같이 F1 점수에 다른 가중치 기준을 적용하여 분류기를 평가할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_train_knn_pred = cross_val_predict(knn_clf, X_train, y_multilabel, cv=<span class="number">3</span>) </span><br><span class="line">f1_score(y_multilabel, y_train_knn_pred, average = <span class="string">&quot;macro&quot;</span>) <span class="comment"># 모든 레이블의 가중치가 같음 </span></span><br><span class="line">f1_score(y_multilabel, y_train_knn_pred, average = <span class="string">&quot;weighted&quot;</span>) <span class="comment"># 타깃 레이블에 속한 샘플 수(지지도)에 가중치를 둠</span></span><br></pre></td></tr></table></figure>
<br />



<h2 id="3-7-다중-출력-분류"><a href="#3-7-다중-출력-분류" class="headerlink" title="3.7 다중 출력 분류"></a>3.7 다중 출력 분류</h2><p>다중 출력 분류(다중 출력 다중 클래스 분류) 시스템 : 다중 레이블 분류에서 각 레이블이 다중 클래스가 될 수 있도록 일반화한 시스템</p>
<p>이를 잡음이 포함된 이미지를 예시로 설명해보자면, 잡음이 포함된 이미지의 각 픽셀은 하나의 레이블에 해당되며 모든 픽셀은 0~255의 다양한 값을 가질 수 있다. 해당 이미지에서 잡음을 제거 시 각 픽셀의 값은 변화하므로 다중 클래스가 될 수 있다. 따라서 이는 다중 레이블에 다중 클래스가 합쳐진 다중 출력 다중 클래스 분류이다.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/machine-learning/" rel="tag"># machine learning</a>
              <a href="/tags/Hands-On-Machine-Learning/" rel="tag"># Hands-On Machine Learning</a>
              <a href="/tags/Keras/" rel="tag"># Keras</a>
              <a href="/tags/Tensorflow/" rel="tag"># Tensorflow</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/22/Data2Vis-code-review/" rel="prev" title="Data2Vis 코드 리뷰">
      <i class="fa fa-chevron-left"></i> Data2Vis 코드 리뷰
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/26/basic-Python/" rel="next" title="Python Overview">
      Python Overview <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-MNIST"><span class="nav-number">1.</span> <span class="nav-text">3.1 MNIST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%EC%9D%B4%EC%A7%84-%EB%B6%84%EB%A5%98%EA%B8%B0-%ED%9B%88%EB%A0%A8"><span class="nav-number">2.</span> <span class="nav-text">3.2 이진 분류기 훈련</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95"><span class="nav-number">3.</span> <span class="nav-text">3.3 성능 측정</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%EA%B5%90%EC%B0%A8-%EA%B2%80%EC%A6%9D%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%A0%95%ED%99%95%EB%8F%84-%EC%B8%A1%EC%A0%95"><span class="nav-number">3.1.</span> <span class="nav-text">3.3.1 교차 검증을 사용한 정확도 측정</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%EC%98%A4%EC%B0%A8-%ED%96%89%EB%A0%AC"><span class="nav-number">3.2.</span> <span class="nav-text">3.3.2 오차 행렬</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%EC%A0%95%EB%B0%80%EB%8F%84%EC%99%80-%EC%9E%AC%ED%98%84%EC%9C%A8"><span class="nav-number">3.3.</span> <span class="nav-text">3.3.3 정밀도와 재현율</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%EC%A0%95%EB%B0%80%EB%8F%84-%EC%9E%AC%ED%98%84%EC%9C%A8-%ED%8A%B8%EB%A0%88%EC%9D%B4%EB%93%9C%EC%98%A4%ED%94%84"><span class="nav-number">3.4.</span> <span class="nav-text">3.3.4 정밀도&#x2F;재현율 트레이드오프</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-ROC-%EA%B3%A1%EC%84%A0"><span class="nav-number">3.5.</span> <span class="nav-text">3.3.5 ROC 곡선</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%EB%8B%A4%EC%A4%91-%EB%B6%84%EB%A5%98"><span class="nav-number">4.</span> <span class="nav-text">3.4 다중 분류</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%EC%97%90%EB%9F%AC-%EB%B6%84%EC%84%9D"><span class="nav-number">5.</span> <span class="nav-text">3.5 에러 분석</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%EB%8B%A4%EC%A4%91-%EB%A0%88%EC%9D%B4%EB%B8%94-%EB%B6%84%EB%A5%98"><span class="nav-number">6.</span> <span class="nav-text">3.6 다중 레이블 분류</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%EB%8B%A4%EC%A4%91-%EC%B6%9C%EB%A0%A5-%EB%B6%84%EB%A5%98"><span class="nav-number">7.</span> <span class="nav-text">3.7 다중 출력 분류</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JungHyun"
      src="/images/profile.jpeg">
  <p class="site-author-name" itemprop="name">JungHyun</p>
  <div class="site-description" itemprop="description">Continuously Growing Developer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/leahincom" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;leahincom" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:leahincom@gmail.com" title="E-Mail → mailto:leahincom@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JungHyun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
