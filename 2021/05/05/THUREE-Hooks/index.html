<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source Code Pro:300,300italic,400,400italic,700,700italic|Source Code Pro, Noto Sans KR:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leahincom.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Hooks    기본 Hook    useState1const [state, setState] &#x3D; useState(initialState);  useState() : state 와 setState 을 반환하는 함수  initialState : 초기값 보통 null 이나 &quot;&quot; 등의 default value로 설정한다.     state :">
<meta property="og:type" content="article">
<meta property="og:title" content="Hooks">
<meta property="og:url" content="https://leahincom.github.io/2021/05/05/THUREE-Hooks/index.html">
<meta property="og:site_name" content="leah">
<meta property="og:description" content="Hooks    기본 Hook    useState1const [state, setState] &#x3D; useState(initialState);  useState() : state 와 setState 을 반환하는 함수  initialState : 초기값 보통 null 이나 &quot;&quot; 등의 default value로 설정한다.     state :">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://coder.earth/static/usecallback_1-aa6572c6cb98757914009ef9063d2204-04c70.png">
<meta property="og:image" content="https://coder.earth/static/usecallback_5-0aacccaf0b04a87b0fa2cf7eab59baaf-04c70.png">
<meta property="og:image" content="https://coder.earth/static/usecallback_7-bd85d59569c0dc834c931abc121027b8-04c70.png">
<meta property="article:published_time" content="2021-05-05T14:44:17.000Z">
<meta property="article:modified_time" content="2021-07-24T09:56:50.825Z">
<meta property="article:author" content="JungHyun">
<meta property="article:tag" content="SOPT">
<meta property="article:tag" content="WEB">
<meta property="article:tag" content="ReactJS">
<meta property="article:tag" content="Hooks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://coder.earth/static/usecallback_1-aa6572c6cb98757914009ef9063d2204-04c70.png">

<link rel="canonical" href="https://leahincom.github.io/2021/05/05/THUREE-Hooks/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Hooks | leah</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">leah</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">my dev_log</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leahincom.github.io/2021/05/05/THUREE-Hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.jpeg">
      <meta itemprop="name" content="JungHyun">
      <meta itemprop="description" content="Continuously Growing Developer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leah">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hooks
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-05 15:44:17" itemprop="dateCreated datePublished" datetime="2021-05-05T15:44:17+01:00">2021-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-24 10:56:50" itemprop="dateModified" datetime="2021-07-24T10:56:50+01:00">2021-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sopt/" itemprop="url" rel="index"><span itemprop="name">SOPT</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sopt/thuree/" itemprop="url" rel="index"><span itemprop="name">THUREE</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><br />



<h3 id="기본-Hook"><a href="#기본-Hook" class="headerlink" title="기본 Hook"></a>기본 Hook</h3><br />



<h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>useState()</code> : <code>state</code> 와 <code>setState</code> 을 반환하는 함수</p>
<ul>
<li><code>initialState</code> : 초기값<ul>
<li>보통 <code>null</code> 이나 <code>&quot;&quot;</code> 등의 default value로 설정한다.</li>
</ul>
</li>
</ul>
</li>
<li><p><code>state</code> : 상태 유지 (저장) 값</p>
<ul>
<li>최초 렌더링 시 반환된 <code>state</code> 는 <code>initialValue</code> 이다.</li>
</ul>
</li>
<li><p><code>setState</code> : <code>state</code> 값을 갱신하는 함수</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(newState);</span><br></pre></td></tr></table></figure>
<ul>
<li>새 <code>state</code> 값을 받으면 컴포넌트 리렌더링을 큐에 등록한다.</li>
<li>리렌더링 시 <code>useState</code> 가 반환하는 첫번째 값 (인자) 은 갱신된 최신 <code>state</code> 이다.</li>
</ul>
</li>
</ul>
<br />



<blockquote>
<p>Note</p>
<p>React guarantees that <code>setState</code> function identity is stable and won’t change on re-renders. This is why it’s safe to omit from the <code>useEffect</code> or <code>useCallback</code> dependency list.</p>
</blockquote>
<br />

<h5 id="Functional-Updates"><a href="#Functional-Updates" class="headerlink" title="Functional Updates"></a>Functional Updates</h5><blockquote>
<p> 함수적 갱신</p>
</blockquote>
<br />



<ol>
<li><p><code>setState</code> 가 값을 갱신하는 과정을 직접 코드로 작성하면 다음과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(&#123;&#125;);</span><br><span class="line">setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Object.assign would also work</span></span><br><span class="line">  <span class="keyword">return</span> &#123;...prevState, ...updatedValues&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>갱신된 객체를 자동으로 merge하는 <code> useState</code> 와 반대로, <code>setState</code> 는 <code>initialValue</code> 를 유지한다.</p>
</blockquote>
<p>이전 <code>state</code> 를 이용해서 값을 <strong>갱신</strong>하는 경우, 이전 값을 받아 갱신된 값을 반환하는 함수를 <code>setState</code> 로 전달하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params">&#123; initialCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 초기화</span></span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(initialCount)&#125;&gt;Reset&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 이전 값을 이용해서 값을 갱신하는 경우</span></span><br><span class="line">			<span class="comment">// parameter value : 현재 값</span></span><br><span class="line">			<span class="comment">// return value : 갱신할 값</span></span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount - <span class="number">1</span>)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />



</li>
</ol>
<blockquote>
<p>Note</p>
<p>Another option is <code>useReducer</code>, which is more suited for managing state objects that contain multiple sub-values.</p>
</blockquote>
<br />



<ol start="2">
<li>업데이트 함수 (setState에 전달한 함수) 가 현재 상태와 정확히 동일한 값을 반환한다면 바로 뒤에 일어날 리렌더링은 완전히 건너뛰게 된다.</li>
</ol>
<br />



<blockquote>
<p><strong>React에서 <code>&#123;&#125;</code> 를 쓰는 경우</strong></p>
<ul>
<li>JSX 내부에서는 객체를 받아옴<ul>
<li><code>&#123;&#123;&#125;&#125;</code> : 객체를 받아오는 것이 아니라 JSX 내부에서 생성할 때</li>
</ul>
</li>
<li>JSX 외부에서는 일반 JS의 문법 중 function destructurizing을 실행</li>
</ul>
</blockquote>
<br />



<h5 id="Lazy-Initial-State"><a href="#Lazy-Initial-State" class="headerlink" title="Lazy Initial State"></a>Lazy Initial State</h5><blockquote>
<p> 지연 초기 state</p>
</blockquote>
<br />



<p><code>initialState</code> 인자는 초기 렌더링 시에 사용하는 <code>state (값)</code> 으로, 리렌더링 시 이 값은 무시된다.</p>
<p>만약 초기 state가 고비용 계산의 결과라면, 초기 렌더링 시에만 실행될 함수를 정의하여 전달하는 것이 효율적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<br />



<h5 id="Bailing-Out-of-a-State-Update"><a href="#Bailing-Out-of-a-State-Update" class="headerlink" title="Bailing Out of a State Update"></a>Bailing Out of a State Update</h5><blockquote>
<p>state 갱신의 취소</p>
</blockquote>
<br />



<p>앞서 설명한 <em>“업데이트 함수 (setState에 전달한 함수) 가 현재 상태와 정확히 동일한 값을 반환한다면 바로 뒤에 일어날 리렌더링은 완전히 건너뛰게 된다.”</em> 를 추가적으로 설명하자면,</p>
<p>State Hook을 현재 state와 동일한 값으로 갱신 (update) 할 경우, 리액트는 children or firing effects를 렌더링하는 과정을 건너뛰고 실행 (처리) 을 종료한다.</p>
<br />



<blockquote>
<p>Note</p>
<p>React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with <code>useMemo</code>.</p>
</blockquote>
<br />



<h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>함수형 컴포넌트 내에서는 <em>React’s render phase</em>에 따라 <em>Mutations, subscriptions, timers, logging, and other side effects</em> 가 허용되지 않는다.</p>
<p>이를 위해 <code>useEffect</code> 를 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(didUpdate);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useEffect()</code> : 모든 렌더링이 완료된 후 / 어떤 값이 변경되었을 때에만 동작 ( <code>didUpdate</code> ) 을 수행</li>
<li><code>didUpdate</code> : 특정 effect를 발생시키는 (명령형) 함수</li>
</ul>
<br />



<h5 id="Cleaning-Up-an-Effect"><a href="#Cleaning-Up-an-Effect" class="headerlink" title="Cleaning Up an Effect"></a>Cleaning Up an Effect</h5><blockquote>
<p>effect 정리</p>
</blockquote>
<br />



<p>Effect는 컴포넌트가 화면에서 제거될 때 정리되어야 하는 요소 (e.g. subscription, timer ID 등) 를 만들곤 한다. 이를 정리하는 함수를 <code>useEffect</code> 에 전달할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// new subscription is created on every update</span></span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Clean up the subscription</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>clean-up function</code> (e.g. <code>subscription.unsubscribe()</code> )은 <strong>컴포넌트가 제거되기(=== 다음의 effect) <em>이전</em> 에 실행되어</strong> memory leaks를 방지한다.</li>
<li>컴포넌트가 여러번 리렌더링 될 경우, <strong>이전의 effect는 다음의 effect가 실행되기 <em>이전</em> 에 정리된다.</strong></li>
</ul>
<br />



<h5 id="Timing-of-Effects"><a href="#Timing-of-Effects" class="headerlink" title="Timing of Effects"></a>Timing of Effects</h5><blockquote>
<p>effect 타이밍</p>
</blockquote>
<br />



<p><code>useEffect</code>에 전달된 함수의 경우 레이아웃 배치과 그리기를 완료한 후, 지연된 이벤트가 발생하는 동안 실행된다. 이는 브라우저가 화면을 업데이트하는 과정을 방해하지 않기 때문에, 여러 <em>side effects (e.g. setting up subscriptions and event handlers)</em> 를 실행하기에 적합한 때이다.</p>
<p><code>useEffect</code> 는 브라우저가 그려지기 이전까지는 대기하지만, 새로운 렌더링이 발생하기 이전에 실행되는 것을 보장한다. 리액트는 언제나 새로운 업데이트가 발생하기 이전에 이전의 렌더링 effect를 모두 제거한다.</p>
<br />



<blockquote>
<p><code>useLayoutEffect</code></p>
<p>DOM 변경과 같이 사용자에게 effect가 보여지는 경우, visual inconsistency 방지를 위해 다음 execution (event) 이 실행되기 이전에 현재 화면이 렌더링이 됨과 동시에 effect가 (<em>synchronously</em>) 발생하여야 한다.</p>
</blockquote>
<br />



<h5 id="Conditionally-Firing-an-Effect"><a href="#Conditionally-Firing-an-Effect" class="headerlink" title="Conditionally Firing an Effect"></a>Conditionally Firing an Effect</h5><blockquote>
<p>조건부 effect 발생</p>
</blockquote>
<br />



<p>Effect의 default behavior은 렌더링이 모두 완료된 이후 실행되는 것이다. 이는 해당 effect의 dependency 중 하나가 변경될 때마다 새로 실행됨을 의미한다.</p>
<p>앞선 예제를 통해서 자세히 보면,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// new subscription is created on every update</span></span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Clean up the subscription</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>subscription</code> 은 매 업데이트마다 생성될 필요 없이, <code>source prop</code> 이 변할 때만 새로 생성되면 된다.</p>
<p>이와 같은 현상을 방지하기 위해, <code> useEffect</code> 의 2번째 argument로 effect가 의존하는 (<em>depend on, dependency</em>) 배열을 전달한다.</p>
<p>따라서 위 예제를 수정해보면,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(</span><br><span class="line">  <span class="comment">// 전달하는 함수는 동일하되,</span></span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      subscription.unsubscribe();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 두번째 인자로 dependency array (depend on하는 배열) 을 전달한다.</span></span><br><span class="line">  [props.source],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>이를 통해 <code>subscription</code>은 <code>props.source</code>가 변경될 때에만 재생성된다.</p>
<br />



<p>만약 effect를 (mount 또는 unmount 시) 한 번만 수행하고 싶다면 두번째 인자로 빈 배열 ( <code>[]</code> ) 을 전달하면 된다. 이를 통해 effect는 컴포넌트 범위에서 가져온 값들 (e.g. props, state 등) 에 전혀 의존하지 않으므로 해당 값들이 변경되어도 다시 실행되지 않는다.</p>
<p>빈 배열 ( <code>[]</code> ) 은 effect 안에 있는 <code>props</code> 와 <code>state</code> 가 항상 초기값을 가지게 됨을 의미한다. 이는 <code>componentDidMount</code> 와 <code>componentWillUnMount</code> 의 기능과 같다.</p>
<br />



<blockquote>
<p>두번째 인자로 전달하는 배열은 effect에 사용되는 컴포넌트 범위의 모든 값 (e.g. props, state 등) 들을 포함해야 한다. 이를 위반할 시 이전 렌더링에서 설정한 값을 참조하는 버그가 발생한다.</p>
<p>이렇게 전달된 dependency 배열은 effect 함수에 인자로 전달되지 않는다. 하지만 effect 함수 내에서 참조된 모든 값들이 해당 배열에 포함되어야 하므로, 전달 여부는 유의미하지 않다.</p>
</blockquote>
<br />



<h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useContext()</code> : <em>( <code>React.createContext</code> 를 통해 반환된 값인 )</em> context 객체에 **현재 context 값 (<code>MyContext</code>) **을 반환한다.<ul>
<li>가장 가까운 상위 컴포넌트 <code>&lt;MyContext.Provider&gt;</code> 가 업데이트 되면, <code>useContext</code> 는 해당 컴포넌트에 전달 (포함) 된 <strong>가장 최신</strong>의 context value 에 따라 화면을 리렌더링 한다.</li>
</ul>
</li>
<li><code>MyContext</code> : <strong>현재 context 값 (객체)</strong> 으로, 트리 구조에서 해당 컴포넌트의 <strong>상위 컴포넌트이면서 가장 가까운</strong> <code>&lt;MyContext.Provider&gt;</code> 의 <code>value prop</code> 에 따라 결정된다.<ul>
<li><code>useContext()</code> 의 인자는 <strong>context 객체</strong>여야 한다.<ul>
<li><strong>Correct:</strong> <code>useContext(MyContext)</code></li>
<li><strong>Incorrect:</strong> <code>useContext(MyContext.Consumer)</code></li>
<li><strong>Incorrect:</strong> <code>useContext(MyContext.Provider)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<br />



<p><code>useContext</code> 를 사용한 컴포넌트는 context 값이 변경될 때마다 리렌더링된다. 리렌더링 되는 컴포넌트가 비싸다면, <code>momoization</code> 을 이용해 효율성을 높일 수 있다.</p>
<blockquote>
<p>상위 컴포넌트에서 <code>React.memo</code> 나 <code>shouldComponentUpdate</code> 를 쓰더라도, <code>useContext</code> 를 사용한 컴포넌트부터 리렌더링이 진행 (시작) 된다.</p>
</blockquote>
<br />



<p><code>useContext</code> 는 context를 <strong>읽고 변경사항을 구독 (확인)</strong> 하는 것만 가능하기 때문에, 해당 context의 값을 <strong>전달</strong>하기 위해 트리 구조 내 상위 컴포넌트로서 <code>&lt;MyContext.Provider&gt;</code> 가 필요하다.</p>
<br />



<h5 id="Putting-it-together-with-Context-Provider"><a href="#Putting-it-together-with-Context-Provider" class="headerlink" title="Putting it together with Context.Provider"></a>Putting it together with Context.Provider</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">    background: <span class="string">&quot;#eeeeee&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    background: <span class="string">&quot;#222222&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// useContext의 인자로서 ThemeContext 객체 전달</span></span><br><span class="line">  <span class="comment">// theme = &lt;ThemeContext.Provider&gt;의 value인 &#123;themes.dark&#125; // 객체</span></span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button style=&#123;&#123; <span class="attr">background</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />

<br />



<hr>
<h3 id="추가-Hooks"><a href="#추가-Hooks" class="headerlink" title="추가 Hooks"></a>추가 Hooks</h3><br />



<h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><p><code>useState()</code> 의 대체재로서 사용한다. 여러 하위 값을 포함하거나 다음 state가 이전의 state 값에 영향을 받는 복잡한 state 로직을 가진 경우 선호된다.</p>
<p>컴포넌트의 state 업데이트 로직을 컴포넌트에서 분리하여 컴포넌트 바깥에서 작성하거나 다른 파일에서 작성한 후 불러와서 사용할 수도 있다.</p>
<p>또한 <code>callback</code> 대신 <code>dispatch</code>를 전달한 수 있어 <strong>deep update</strong>를 요구하는 컴포넌트의 경우 performance를 최적화할 수 있다.</p>
<blockquote>
<p><em>What is <strong>deep update</strong> in React?</em></p>
<p>먼저, React에서 <strong>update</strong>란; <code>useState()</code> 를 사용하는 모든 리액트 컴포넌트에서 사용가능한 함수로, 컴포넌트 state가 변경되었을 때 리액트에게 이를 알림으로써 해당 state에 종속된 UI를 업데이트하기 위해 컴포넌트에게 리렌더링이 필요하다는 것을 전달한다. </p>
<p>따라서, <strong>deep update</strong>란 <em>deep nested 객체 (many pieces of information과 fixed 스키마를 가진) 를 update</em> 하는 것을 의미한다. </p>
</blockquote>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>useReducer()</code> : <code>reducer</code> 를 받아 현재 <code>state</code>와 짝지어진 <code>dispatch</code> 함수를 반환한다.</p>
</li>
<li><p><code>reducer</code> : 현재 <code>state</code>와 <code>action</code> 객체를 파라미터로 받아와서 ( <code>(state, action)</code> ) 새로운 state를 반환하는 함수</p>
<ul>
<li><p><code>(state, action) =&gt; newState</code> 의 구조를 가진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 새로운 state를 만드는 로직</span></span><br><span class="line">  <span class="comment">// const nextState = ...</span></span><br><span class="line">  <span class="keyword">return</span> nextState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>반환하는 해당 state는 컴포넌트가 지닐 <strong>새로운 state</strong>가 된다.</p>
</li>
<li><p><code>action</code> : 업데이트를 위한 정보를 가지고 있다.</p>
<ul>
<li><p>주로 <code>type</code> 값을 지닌 객체 형태로 사용한다.</p>
<blockquote>
<p><code> type</code> 의 경우, <strong>대문자</strong> 를 사용하거나 <code>_</code> 로 시작하는 관습이 있다.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>state</code> : 컴포넌트에서 사용할 수 있는 상태</p>
</li>
<li><p><code>dispatch</code> : <code>action</code> 을 (인자로 받아) 발생시키는 함수</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<br />



</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// dispatch의 인자로 action (type) 전달</span></span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />



<blockquote>
<p>Note</p>
<p>리액트는 리렌더링이 되더라도 dispatch 함수의 identity 는 동일하게 유지하기 때문에, useEffect 나 useCallback 의 dependency list에 포함하지 않는다.</p>
</blockquote>
<br />



<h5 id="Specifying-the-Initial-State"><a href="#Specifying-the-Initial-State" class="headerlink" title="Specifying the Initial State"></a>Specifying the Initial State</h5><blockquote>
<p>초기 state의 구체화</p>
</blockquote>
<br />



<p>useReducer() 의 state를 초기화하는 방법에는 2가지가 있다.</p>
<ol>
<li>가장 간단한 방법으로는, initial state를 2번째 인자로 전달하는 방법이 있다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(</span><br><span class="line">	reducer,</span><br><span class="line">  &#123;<span class="attr">count</span>: initialCount&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<br />



<h5 id="Lazy-Initialization"><a href="#Lazy-Initialization" class="headerlink" title="Lazy Initialization"></a>Lazy Initialization</h5><blockquote>
<p> 초기화 지연</p>
</blockquote>
<br />



<ol start="2">
<li>initial state를 lazily 생성하는 방법으로, init 함수를 3번째 인자로 전달하여 initial state를 init(initialArg) 로 설정할 수 있다.<ul>
<li>initial state 를 계산하는 로직을 reducer 밖에 정의하여 action 에 따른 state 재설정 시 유용하게 사용할 수 있다.</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialization 함수를 외부에 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 재설정 시 init 함수 호출</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3개의 인자 전달 (reducer, initial_value, initialization_function)</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 재설정 시 action 객체에 &#123;type, payload&#125; 전달</span></span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span>, <span class="attr">payload</span>: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>payload</code></p>
<p>전송되는 데이터</p>
</blockquote>
<br />



<h5 id="Bailing-Out-of-a-Dispatch"><a href="#Bailing-Out-of-a-Dispatch" class="headerlink" title="Bailing Out of a Dispatch"></a>Bailing Out of a Dispatch</h5><blockquote>
<p> dispatch의 회피</p>
</blockquote>
<br />



<p>앞서 <code>useState()</code> 에서 설명한 것과 같이, Reducer Hook ( <code>useReducer()</code> ) 이 현재 state과 동일한 값을 반환할 경우, 자식을 렌더링하거나 effect를 실행하지 않고 처리 (i.e. 렌더링, 이벤트) 를 종료한다.</p>
<blockquote>
<p><strong><code>Object.is()</code> comparison 알고리즘</strong>을 이용</p>
</blockquote>
<p>처리를 종료하기 전에 해당 컴포넌트를 다시 렌더링해야 하는 경우가 존재하지만, 그 이상으로 깊게 트리를 탐색하지 않으므로 문제가 되지는 않는다. 만약 렌더링에 <em>비싼 계산 과정</em> 이 포함된다면, <code>useMemo()</code> 를 사용할 수 있다.</p>
<br />



<h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><p>memoized callback 을 반환한다.</p>
<br />



<blockquote>
<p><strong><code>memoization</code></strong></p>
<ol>
<li><p>비싼 함수의 호출 결과를 저장하고 같은 input이 발생할 경우 저장된 (캐시) 값을 반환하여 프로그램의 수행 속도를 증가시키는 최적화 (optimization) 기술</p>
</li>
<li><p>(some sort of) 캐시를 이용하여 (비싼) 함수를 부르는 횟수를 제한하는 것</p>
<ul>
<li>특정 input에 대한 캐시값이 없다면, original 함수가 한번 호출되어 (캐시) map에 결과값이 추가된다.</li>
<li>캐시를 지우지 않는 한 결과는 캐시 map에서 반환된다.</li>
</ul>
</li>
</ol>
<br />



<p>👉 <strong><code>useCallback</code> hook 은 다른 기능을 한다.</strong></p>
</blockquote>
<p>🌈 <strong><a target="_blank" rel="noopener" href="https://coder.earth/post/usecallback">REFERENCE</a>를 꼭 읽어보세염 (:-&gt;</strong></p>
<p><code>useCallback()</code> 을 이용하는 이유는, callback 함수인 <code>cb</code>의 <strong>memoized 버전</strong>을 받기 위해서이다.</p>
<p>컴포넌트가 처음으로 렌더링될 때, 새로운 <code>cb</code> 가 생성되고 똑같은 <code>cb</code> 함수가 <code>useCallback()</code> 에 의해 반환된다.</p>
<img src="https://coder.earth/static/usecallback_1-aa6572c6cb98757914009ef9063d2204-04c70.png" align="center" />

<br />



<p>위 예시에서 <code>memoizedCb()</code> 가 호출되면, original <code>cb</code> 콜백함수가 호출되어 결과적으로 original <code>cb 함수</code>를 호출한다.</p>
<p>컴포넌트가 리렌더링 (2번째) 되면, 새로운 <code>cb</code> 가 생성된다. 하지만 <code>useCallback()</code> 에 전달된 dependency가 변하지 않았기 때문에, 생성된 <code>cb</code>는 버려지고 <code>memoizedCb</code>는 첫번째 렌더링 때 생성된 <code>cb</code>를 유지한다. 결국 이 때의 <code>memoizedCb</code> 호출은 이전과 같이 기존의 (old) <code>cb</code> 를 호출하여 original <code>cb 함수</code>를 호출하게 된다.</p>
<p>dependency가 변하지 않는 이상, 모든 렌더링은 위와 같은 과정을 반복하여 사용하지 않는 콜백함수를 생성하고 기존의, memoized 콜백을 호출하여 결국 original <code>cb 함수</code>를 호출한다.</p>
<img src="https://coder.earth/static/usecallback_5-0aacccaf0b04a87b0fa2cf7eab59baaf-04c70.png" align="center" />

<br />



<p>dependency 가 변한 경우, <code>memoizedCb</code> 도 변한다.</p>
<p>이전의 <code>memoizedCb</code> 가 첫번째 <code>cb</code>를 호출하는 과정과 비슷하게, 이 때의 <code>memoizedCb</code> 또한 dependency 가 변한 시점부터 첫번째 <code>cb</code> 를 호출한다.</p>
<img src="https://coder.earth/static/usecallback_7-bd85d59569c0dc834c931abc121027b8-04c70.png" align="center" />

<br />



<blockquote>
<p><strong><code>callback</code></strong></p>
<p>특정 함수 (콜백함수) 를 다른 함수에 전달하고 이를 호출하는 특정 이벤트 (e.g. a query finished or an error occurs) 가 발생하면 콜백함수를 발생시키는 것</p>
<ul>
<li>여러 조각의 코드의 소통을 정의하여, 콜백함수를 호출하는 모듈이 결과를 사용하는 것이 아니라 이벤트가 발생했을 때 호출을 받는 함수에 콜백함수를 전달한다.</li>
<li>여기서 중요한 점은, one piece of code가 콜백함수를 호출하면 다른 (조각의) 코드가 이 호출을 받는다는 것이다. 여기서 어떠한 호출 코드도 잃으면 (생략되면) 안 되기 때문에, 콜백함수를 memoizing하여 모듈 간 소통 line을 끊는 방법이 탄생한 것이다.</li>
</ul>
</blockquote>
<p>결과적으로 <code>useCallback()</code> 이 하는 것은 똑같은 callback 의 횟수를 제한하는 것이다. 결과값들은 캐시에서 반환되지 않고, dependency 가 변한 시점으로부터 첫번째의 <code>cb</code> 와 같은 <code>memoizedCb</code> 를 반환한다.</p>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useCallback()</code> : inline callback 함수와 dependencies 배열을 전달<ul>
<li><strong>memoized version of the callback</strong>을 반환하며, dependencies가 변했을 때만 memoized version 도 변경된다.</li>
<li><code>useCallback(fn, deps)</code> === <code>useMemo(() =&gt; fn, deps)</code></li>
</ul>
</li>
</ul>
<br />



<p>불필요한 렌더링을 방지하기 위해 reference의 동일성에 의존하는 (동일성에만 영향을 받는) (최적화된) 자식 컴포넌트에 콜백함수를 전달할 때 유용하다.</p>
<blockquote>
<p>앞선 <code>useEffect</code>와 마찬가지로, dependencies 배열은 콜백함수에 인자로 전달되지 않는다.</p>
<p>하지만 정의 자체가, <em>“콜백함수에서 참조하는 모든 값들은 dependencies 배열에 포함되어야 한다”</em> 이다.</p>
</blockquote>
<br />



<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><p>memoized 값을 반환한다.</p>
<blockquote>
<p><code>useMemo</code> vs. <code>useCallback</code></p>
<p><code>useCallback()</code> : 함수 반환</p>
<p><code>useMemo()</code> : 값 반환</p>
</blockquote>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function">() =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useMemo()</code> : <code>create 함수</code>와 <code>dependencies 배열</code> 을 전달<ul>
<li>dependency 가 변할 때에만 memoized 값을 다시 계산한다. 이를 통해 비싼 계산 과정이 매 렌더링마다 발생하는 것을 방지한다.</li>
<li>2번째 인자 (<code>dependencies 배열</code> 로서) 에 빈 배열 ( <code>[]</code> ) 이 전달되면, 매 렌더링 마다 새로운 값이 계산된다.</li>
</ul>
</li>
</ul>
<br />



<p><code>useMemo()</code> 에 전달된 <code>create 함수</code> 는 <em><strong>렌더링 동안</strong></em> 실행된다.</p>
<blockquote>
<p>보통 side effect는 <code>useMemo</code> 가 아니라 <strong><code>useEffect</code> 에서 발생</strong>한다. 따라서 렌더링 동안은 다른 행동을 하지 않아야 한다. (당연함 -.-)</p>
</blockquote>
<br />



<blockquote>
<p>❗️<code>useMemo()</code> 는 성능 최적화에만 사용하고, 큰 의미적 기능 (semantic guarantee) 을 담지 않아야 한다. 따라서 <code>useMemo()</code> 를 사용하지 않고도 동작할 수 있도록 코드를 작성하고, 성능 최적화를 위해 <code>useMemo()</code> 를 추가하도록 한다.</p>
</blockquote>
<blockquote>
<p>앞선 <code>useEffect</code>, <code>useCallback</code> 과 마찬가지로, <code>depedencies 배열</code> 은 콜백함수에 인자로 전달되지 않는다.</p>
</blockquote>
<br />



<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>JavaScript를 이용해 특정 <strong>DOM 을 선택</strong>해야 하는 경우 <code>getElementById</code>, <code>querySelector</code> 와 같은 <em>DOM Selector 함수</em> 를 사용한다.</p>
<p>리액트를 사용할 때도 특정 DOM 을 선택해야 하는 상황이 발생하는데, 이 때 <code>ref</code> 를 사용한다.</p>
<ul>
<li><strong>함수형 컴포넌트</strong>에서 <code>ref</code> 를 사용 할 때에는 <code>useRef</code> 라는 <em>Hook 함수</em> 를 사용한다.</li>
<li><strong>클래스형 컴포넌트</strong>에서는 <em>콜백 함수</em>를 사용하거나 <code>React.createRef</code> 라는 함수를 사용한다.</li>
</ul>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useRef()</code> : <em>(생성된 ref 객체의)</em> <code>.current</code> 프로퍼티 (속성) 가 전달된 인자 (e.g. <code>initialValue</code>) 로 초기화된, <strong>변경 가능한 ref 객체</strong>를 반환한다.<ul>
<li>변경가능한 값을 넣을 수 있는 <code>.current 프로퍼티</code>를 갖고 있는 <u>“박스”</u> 와 같다.</li>
<li>해당 객체는 컴포넌트의 <em>full lifetime</em> 동안 지속된다.</li>
</ul>
</li>
</ul>
<br />



<p><code>useRef()</code> 는 <strong>DOM에 접근</strong>하는 방법으로 많이 사용된다.</p>
<p><code>useRef()</code> 를 사용하여</p>
<ol>
<li><strong>Ref 객체</strong>를 만들고,</li>
<li>이 객체를 우리가 <strong>선택하고 싶은 DOM (노드) 에 <code>ref</code> 값으로</strong> 설정한다.</li>
<li>그러면, <strong>Ref 객체의 <code>.current</code> 값은 우리가 원하는 DOM 을 가르키</strong>게 된다.</li>
</ol>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&#123;refContainer&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><code>refContainer</code> 의 <code>.current</code> 프로퍼티를 해당 ref 객체  ( <code>refContainer</code> ) 를 ref 로 설정한 DOM 노드로 설정하고, 노드가 변경될 때마다 그에 맞게 <code>.current</code> 프로퍼티를 조정한다.</p>
<blockquote>
<p>하지만 <code>useRef()</code> 는 <code>.current</code> 에 변경 사항이 존재하더라도 <strong>리렌더링 하지 않</strong>기 때문에, 이에 대해 <strong>notify 하지 않는다</strong>. 만약 리액트가 DOM 노드에 ref 객체를 연결하거나 제거할 때 notify 하고 싶다면, <code>callback ref</code> 를 이용해야 한다.</p>
</blockquote>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInput_With_FocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// inputEl : ref 객체 (null로 초기화됨)</span></span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// button을 클릭하면 inputEl.current 인 input node에 focus() 를 적용한다.</span></span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` points to the mounted text input element</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">    	<span class="comment">// inputEl ref 객체를 ref로 설정하여 inputEl.current 프로퍼티를 input node 로 설정한다.</span></span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">&quot;text&quot;</span> /&gt;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// onClick 시 onButtonClick 함수를 실행하고 // 👉 goto onButtonClick comment</span></span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>HTMLElement.focus()</code></strong></p>
<p>특정 element 에 <em>(focus를 맞출 수 있을 때)</em> focus를 맞추는 함수로, 해당 element는 키보드 등의 이벤트를 받는 default element로 정의된다.</p>
</blockquote>
<br />



<hr>
<br />



<p><code>useRef()</code> 는 ref 속성 외에도, 클래스가 instance field (인스턴스 변수) 를 가지고 있는 것처럼 ref 객체에 변경 가능한 어떠한 값도 담을 수 있다는 장점이 있다.</p>
<p>이는 <code>useRef()</code> 가 <em>plain JavaScript 객체</em> 를 생성하기 때문인데, 직접 <code>&#123;current: ...&#125;</code> 로 객체를 생성하는 것과 유일한 차이점은 <code>useRef()</code> 는 매 렌더링마다 <strong>똑같은 ref 객체를 제공 (반환) 한다</strong>는 것이다.</p>
<blockquote>
<p><strong><code>class field (클래스 변수)</code> vs. <code>instance field (인스턴스 변수)</code></strong></p>
<ul>
<li>클래스 변수 : 여러 인스턴스 (서로 다른 객체) 간에 <strong>공유해야 하는 값</strong>을 바인딩</li>
<li>인스턴스 변수 : 각 인스턴스 (객체) 마다 가지고 있는 고유한 값</li>
</ul>
<p>파이썬은 인스턴스를 통해 접근한 이름 (변수) 이 인스턴스의 name_space (name들을 정의한 공간) 에 없을 경우, 그 다음으로 클래스의 name_space에서 찾아본다.</p>
<p>참고로 클래스 변수에 접근할 때에는 클래스 이름을 사용하여 바로 변수 (값) 에 접근할 수 있다.</p>
</blockquote>
<br />



<h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><blockquote>
<p>❗️ref를 사용하는 <em>imperative code</em> 는 되도록이면 피하는 것이 좋다. <strong>):-&lt;</strong></p>
</blockquote>
<p>ref를 사용할 때 부모 컴포넌트에 노출되는 <em>인스턴스 값 (변수) 을 커스터마이징</em> 한다.</p>
<p>즉, forwarding된 ref를 replace할 수 있는 기능을 제공한다.</p>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>
<ul>
<li><p>useImperativeHandle() : <code>ref</code>, <code>콜백함수 (createHandle)</code>, <code>dependnecies 배열</code> 을 전달</p>
<ul>
<li><code>createHandle()</code> : 현재 컴포넌트의 값을 부모 컴포넌트가 접근할 수 있도록 하는 콜백함수</li>
</ul>
</li>
<li><p><code>forwardRef()</code> 와 함께 사용되어야 한다.</p>
<blockquote>
<p><code>forwardRef()</code> </p>
<p>(말 그대로) reference를 전달해주는 기능을 하는 함수</p>
</blockquote>
</li>
</ul>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    focus: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure>
<p><code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 를 수행 (렌더링) 하는 부모 컴포넌트는 <code>inputRef.current.focus()</code> 를 호출할 수 있다.</p>
<br />



<h4 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h4><p><code>useEffect</code> 와 동일한 기능을 DOM 변경 시 동시에 (synchronously) 실행하는 함수로, DOM 에서 레이아웃을 읽음과 동시에 리렌더링을 해야할 때 사용한다.</p>
<p><code>useLayoutEffect</code> 내부에 정의된 예정된 업데이트 또한 브라우저가 레이아웃을 그리기 이전에, 읽음과 동시에 발생한다.</p>
<blockquote>
<p>화면 업데이트를 차단하지 않아도 되는 경우에는 <code>useEffect</code> 를 사용하는 것이 좋다.</p>
</blockquote>
<br />



<blockquote>
<p> 클래스 컴포넌트에서 코드를 옮길 때 <code>useLayoutEffect()</code> 는 <code>componentDidMount</code> 나 <code>componentDidUpdate</code> 와 같은 단계에서 발생한다. 하지만, 먼저 <code>useEffect</code> 를 시도해보고 에러가 발생할 때 <code>useLayoutEffect</code> 를 사용하는 것이 좋다.</p>
</blockquote>
<blockquote>
<p><strong>SSR (서버 사이드 렌더링)</strong> 의 경우, <code>useLayoutEffect</code> 나 <code>useEffect</code> 는 JavaScript 가 모두 다운되기 전까지는 실행되지 않는다. SSR 컴포넌트가 <code>useLayoutEffect</code> 를 포함한 경우,</p>
<ul>
<li>첫 렌더링 시 해당 컴포넌트가 필요하지 않다면 <code>useEffect</code> 로 로직을 옮기고,</li>
<li><code>useLayoutEffect</code> 가 실행되기 전까지 HTML이 망가져 보인다면 클라이언트 렌더링이 완료될 때까지 해당 컴포넌트를 보여주는 것을 딜레이시킨다.</li>
</ul>
<p>서버 렌더링 HTML에서 레이아웃 effect를 필요로 하는 컴포넌트를 제외하기 위해서, </p>
<ul>
<li><code>showCild &amp;&amp; &lt;Child /&gt;</code> 를 이용하여 해당 컴포넌트를 조건적으로 렌더링을 하고, </li>
<li><code>useEffect(() =&gt; &#123; setShowChild(true); &#125;, [])</code> 를 이용하여 보이는 것을 미룬다 (defer).</li>
</ul>
<p>이를 통해 HTML이 hydration (<code>useLayoutEffect</code>, <code>useEffect</code> 실행) 이전에 망가져 보이는 것을 방지한다.</p>
</blockquote>
<br />



<h4 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(value)</span><br></pre></td></tr></table></figure>
<p>React DevTools 에서 커스텀 Hooks의 <code>label (value)</code> 을 보여준다.</p>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Show a label in DevTools next to this Hook</span></span><br><span class="line">  <span class="comment">// e.g. &quot;FriendStatus: Online&quot;</span></span><br><span class="line">  useDebugValue(isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />



<blockquote>
<p>모든 커스텀 Hook에 debug value를 추가하는 것은 좋지 않다.</p>
<p><strong>shared libraries에 속하는 커스텀 Hooks</strong>에 유용하게 사용될 수 있다.</p>
</blockquote>
<br />



<h5 id="Defer-Formatting-Debug-Values"><a href="#Defer-Formatting-Debug-Values" class="headerlink" title="Defer Formatting Debug Values"></a>Defer Formatting Debug Values</h5><blockquote>
<p> 디버그 값 포맷팅 지연하기</p>
</blockquote>
<br />



<p>디스플레이 (되는) 값을 포매팅하는 것은 고비용 연산일 수 있고, <em>Hook이 감지되지 않은 경우 사실상 포매팅은 불필요하다</em>. 따라서, <code>useDebugValue</code> 의 (optional한) 2번째 인자로 <code>포매팅 함수</code> 를 전달하여 <strong>Hook이 감지되었을 때만 해당 함수를 호출</strong>하여 포매팅할 수 있다.</p>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(value, <span class="function"><span class="params">value</span> =&gt;</span> value.formatting_function());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>useDebugValue()</code> : <code>value</code> 와 <code>optional formatting 함수</code> 를 전달<ul>
<li><code>optional formatting function</code> : <code>debug value</code> 를 인자로 전달하고 <code>formatted display value</code> 를 반환한다.</li>
</ul>
</li>
</ul>
<br />



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(date, <span class="function"><span class="params">date</span> =&gt;</span> date.toDateString());</span><br></pre></td></tr></table></figure>
<p>2번째 인자로 <code>fomatting function</code> 을 전달하여 Date value 를 반환하는 커스텀 Hook이 <code>toDateString()</code> 을 <strong>불필요하게 호출하는 것을 방지</strong>한다.</p>
<br />



<hr>
<br />



<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://ko.reactjs.org/docs/hooks-reference.html">https://ko.reactjs.org/docs/hooks-reference.html</a></p>
<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html">https://reactjs.org/docs/hooks-reference.html</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/sopt/" rel="tag"># SOPT</a>
              <a href="/tags/web/" rel="tag"># WEB</a>
              <a href="/tags/reactjs/" rel="tag"># ReactJS</a>
              <a href="/tags/hooks/" rel="tag"># Hooks</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/24/3%EC%B0%A8-%EC%84%B8%EB%AF%B8%EB%82%98-24-04-21/" rel="prev" title="3차 세미나_24/04/21">
      <i class="fa fa-chevron-left"></i> 3차 세미나_24/04/21
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/08/SOAP-Classes/" rel="next" title="Classes">
      Classes <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hooks"><span class="nav-number">1.</span> <span class="nav-text">Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EA%B8%B0%EB%B3%B8-Hook"><span class="nav-number">1.1.</span> <span class="nav-text">기본 Hook</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useState"><span class="nav-number">1.1.1.</span> <span class="nav-text">useState</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Functional-Updates"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Functional Updates</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lazy-Initial-State"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Lazy Initial State</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bailing-Out-of-a-State-Update"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">Bailing Out of a State Update</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useEffect"><span class="nav-number">1.1.2.</span> <span class="nav-text">useEffect</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cleaning-Up-an-Effect"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Cleaning Up an Effect</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timing-of-Effects"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Timing of Effects</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Conditionally-Firing-an-Effect"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">Conditionally Firing an Effect</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useContext"><span class="nav-number">1.1.3.</span> <span class="nav-text">useContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Putting-it-together-with-Context-Provider"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Putting it together with Context.Provider</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EC%B6%94%EA%B0%80-Hooks"><span class="nav-number">1.2.</span> <span class="nav-text">추가 Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useReducer"><span class="nav-number">1.2.1.</span> <span class="nav-text">useReducer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Specifying-the-Initial-State"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Specifying the Initial State</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lazy-Initialization"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">Lazy Initialization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bailing-Out-of-a-Dispatch"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">Bailing Out of a Dispatch</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useCallback"><span class="nav-number">1.2.2.</span> <span class="nav-text">useCallback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useMemo"><span class="nav-number">1.2.3.</span> <span class="nav-text">useMemo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useRef"><span class="nav-number">1.2.4.</span> <span class="nav-text">useRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useImperativeHandle"><span class="nav-number">1.2.5.</span> <span class="nav-text">useImperativeHandle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useLayoutEffect"><span class="nav-number">1.2.6.</span> <span class="nav-text">useLayoutEffect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useDebugValue"><span class="nav-number">1.2.7.</span> <span class="nav-text">useDebugValue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Defer-Formatting-Debug-Values"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">Defer Formatting Debug Values</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">1.3.</span> <span class="nav-text">Reference</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JungHyun"
      src="/images/profile.jpeg">
  <p class="site-author-name" itemprop="name">JungHyun</p>
  <div class="site-description" itemprop="description">Continuously Growing Developer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/leahincom" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;leahincom" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:leahincom@gmail.com" title="E-Mail → mailto:leahincom@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JungHyun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
